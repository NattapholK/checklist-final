# scheduler_job.py
from datetime import datetime
import firebase_admin
from firebase_admin import credentials, firestore
import os
from dotenv import load_dotenv
import requests
from apscheduler.schedulers.blocking import BlockingScheduler # Use BlockingScheduler for a standalone script
import base64
import json

# Import students list - assuming 'student.py' exists and contains a 'students' list
from student import students

# Load environment variables
load_dotenv()
LINE_ACCESS_TOKEN = os.getenv("LINE_ACCESS_TOKEN")
FIREBASE_SERVICE_BASE64 = os.getenv("FIREBASE_SERVICE")

# --- Firebase Initialization ---
try:
    firebase_key_dict = json.loads(base64.b64decode(FIREBASE_SERVICE_BASE64))
    cred = credentials.Certificate(firebase_key_dict)
    firebase_admin.initialize_app(cred)
    db = firestore.client()
    print("Firebase initialized successfully for scheduler.")
except Exception as e:
    print(f"Error initializing Firebase for scheduler: {e}")
    exit(1) # Critical for scheduler to exit if Firebase fails

# --- LINE Messaging Functions (copied from app.py, as this script runs independently) ---

def send_line_broadcast(message):
    """
    Sends a push message to all registered recipients in Firestore.
    """
    headers = {
        "Authorization": f"Bearer {LINE_ACCESS_TOKEN}",
        "Content-Type": "application/json"
    }

    users_ref = db.collection("recipients")
    try:
        docs = users_ref.stream()
        for doc in docs:
            user_id = doc.id
            payload = {
                "to": user_id,
                "messages": [{"type": "text", "text": message}]
            }
            try:
                response = requests.post("https://api.line.me/v2/bot/message/push", headers=headers, json=payload)
                response.raise_for_status()
                print(f"Broadcast message sent to {user_id}. Status: {response.status_code}")
            except requests.exceptions.RequestException as e:
                print(f"Error sending push message to {user_id}: {e}")
    except Exception as e:
        print(f"Error fetching recipients from Firestore: {e}")

# --- Attendance Report Function ---

def send_attendance_report():
    """
    Generates and sends an attendance report based on Firestore data.
    """
    print("Generating attendance report from scheduler...")
    date_str = datetime.now().strftime("%Y-%m-%d")
    
    attendances_doc_ref = db.collection("attendances").document(date_str)
    users_attendance_ref = attendances_doc_ref.collection("users")

    checked_numbers = set()
    checked_names = []
    
    try:
        docs = users_attendance_ref.stream()
        for doc in docs:
            data = doc.to_dict()
            number = data.get("number")
            name = data.get("name")
            if number and name:
                checked_numbers.add(number)
                checked_names.append(name)
        
        checked_names.sort()

        report = f"üìã ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡πÄ‡∏ä‡πá‡∏Ñ‡∏ä‡∏∑‡πà‡∏≠ ‡∏ï‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤ {datetime.now().strftime('%H:%M')}\n"
        report += f"üìÖ ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: {date_str}\n"
        report += f"üü¢ ‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß: {len(checked_numbers)} ‡∏Ñ‡∏ô\n"
        for name in checked_names:
            report += f"‚úÖ {name}\n"

        absent_names = [
            students[i-1] for i in range(1, len(students) + 1) if i not in checked_numbers
        ]
        absent_names.sort()

        report += f"üî¥ ‡∏Ç‡∏≤‡∏î: {len(absent_names)} ‡∏Ñ‡∏ô\n"
        for name in absent_names:
            report += f"‚ùå {name}\n"
        
        print(f"Attendance report generated by scheduler:\n{report}")
        send_line_broadcast(report)
        print("Attendance report broadcasted by scheduler.")

    except Exception as e:
        print(f"Error generating or sending attendance report from scheduler: {e}")

# --- Scheduler Setup for Standalone Script ---
if __name__ == "__main__":
    print("Starting scheduler job...")
    # Use BlockingScheduler for a script that is meant to run and block until jobs are done
    # or to keep the script alive for cron-like scheduling.
    scheduler = BlockingScheduler()
    
    # Add the job to run daily at 8:30 AM
    scheduler.add_job(send_attendance_report, 'cron', hour=8, minute=30)
    
    # You can also add an initial run for testing or immediate execution
    # scheduler.add_job(send_attendance_report) # Uncomment to run immediately on startup

    try:
        scheduler.start()
    except (KeyboardInterrupt, SystemExit):
        print("Scheduler stopped.")
